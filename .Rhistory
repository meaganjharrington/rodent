))
)
# ---- Inspect and plot ----
head(res_parametric_si$R)
# Full 3-panel plot
plot(res_parametric_si, legend = FALSE)
# Rt panel only + horizontal line at 1
plot(res_parametric_si, "R") +
geom_hline(aes(yintercept = 1), lty = 2, col = "red")
# ---- (Optional) Summarise mean R per window ----
summary_by_window <- res_parametric_si$R %>%
mutate(window = paste0("days ", t_start, "–", t_end)) %>%
select(window, `Mean(R)`, `Quantile.0.025(R)`, `Quantile.0.975(R)`)
print(summary_by_window)
load_all()
# Load necessary libraries
library(dplyr)
library(outbreaks)
# Data
data(ebola_sierraleone_2014)
# 1) Build daily incidence data frame (time, cases)
ebola_daily_incidence <- ebola_sierraleone_2014 %>%
filter(!is.na(date_of_onset)) %>%
group_by(date_of_onset) %>%
summarise(cases = n(), .groups = "drop") %>%
arrange(date_of_onset) %>%
mutate(time = row_number()) %>%
select(time, cases) %>%
as.data.frame()
# 2) Run model
out <- estimate_Rt_draws(
incidence = ebola_daily_incidence,
N = 100000,
gamma = 0.2,
beta_breaks = c(1, 230)
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
library(ggplot2)
plot_block_R <- function(df_block, y_label = "R") {
ggplot(df_block) +
geom_rect(aes(xmin = t_start, xmax = t_end, ymin = Lower, ymax = Upper),
fill = "grey80", alpha = 0.7, color = NA) +
geom_segment(aes(x = t_start, xend = t_end, y = Mean, yend = Mean),
size = 1.2, color = "black") +
geom_hline(yintercept = 1, linetype = 2, color = "red") +
labs(x = "Time", y = y_label, title = paste("Estimated", y_label, "by Block")) +
theme_minimal(base_size = 12)
}
# Using your beta blocks:
plot_block_R(df_block_R)
head(out$Rt_series)
out$Rt_plot # print Rt(t) plot over time
library(EpiEstim)
library(dplyr)
library(ggplot2)
# ---- Your SI (parametric) ----
mean_si <- 5     # days
std_si  <- 5    # days
# ---- Prepare incidence ----
# Expecting ebola_daily_incidence to have columns: date (optional), cases (integer)
ebola_sierraleone_2014_epiestim <- ebola_daily_incidence %>%
rename(I = cases)  # EpiEstim looks for column "I"
# ---- Define NON-OVERLAPPING windows ----
# Example: 2..49 (pre), 50..N (post)
t_start <- c(2, 229)
t_end   <- c(230, nrow(ebola_daily_incidence))
stopifnot(length(t_start) == length(t_end))
stopifnot(all(t_start >= 2))
stopifnot(all(t_end <= nrow(ebola_daily_incidence)))
stopifnot(all(t_end >= t_start))
# ---- Estimate R over the two windows ----
res_parametric_si <- estimate_R(
incid  = ebola_sierraleone_2014_epiestim,  # data.frame with "I" (and optionally "dates")
method = "parametric_si",
config = make_config(list(
mean_si = mean_si,
std_si  = std_si,
t_start = t_start,
t_end   = t_end
))
)
# ---- Inspect and plot ----
head(res_parametric_si$R)
# Full 3-panel plot
plot(res_parametric_si, legend = FALSE)
# Rt panel only + horizontal line at 1
plot(res_parametric_si, "R") +
geom_hline(aes(yintercept = 1), lty = 2, col = "red")
# ---- (Optional) Summarise mean R per window ----
summary_by_window <- res_parametric_si$R %>%
mutate(window = paste0("days ", t_start, "–", t_end)) %>%
select(window, `Mean(R)`, `Quantile.0.025(R)`, `Quantile.0.975(R)`)
print(summary_by_window)
# Load necessary libraries
library(dplyr)
library(outbreaks)
# Data
data(ebola_sierraleone_2014)
# 1) Build daily incidence data frame (time, cases)
ebola_daily_incidence <- ebola_sierraleone_2014 %>%
filter(!is.na(date_of_onset)) %>%
group_by(date_of_onset) %>%
summarise(cases = n(), .groups = "drop") %>%
arrange(date_of_onset) %>%
mutate(time = row_number()) %>%
select(time, cases) %>%
as.data.frame()
# 2) Run model
out <- estimate_Rt_draws(
incidence = ebola_daily_incidence,
N = 100000,
gamma = 0.2,
beta_breaks = c(1, 230)
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
library(ggplot2)
plot_block_R <- function(df_block, y_label = "R") {
ggplot(df_block) +
geom_rect(aes(xmin = t_start, xmax = t_end, ymin = Lower, ymax = Upper),
fill = "grey80", alpha = 0.7, color = NA) +
geom_segment(aes(x = t_start, xend = t_end, y = Mean, yend = Mean),
size = 1.2, color = "black") +
geom_hline(yintercept = 1, linetype = 2, color = "red") +
labs(x = "Time", y = y_label, title = paste("Estimated", y_label, "by Block")) +
theme_minimal(base_size = 12)
}
# Using your beta blocks:
plot_block_R(df_block_R)
head(out$Rt_series)
out$Rt_plot # print Rt(t) plot over time
load_all()
# Load necessary libraries
library(dplyr)
library(outbreaks)
# Data
data(ebola_sierraleone_2014)
# 1) Build daily incidence data frame (time, cases)
ebola_daily_incidence <- ebola_sierraleone_2014 %>%
filter(!is.na(date_of_onset)) %>%
group_by(date_of_onset) %>%
summarise(cases = n(), .groups = "drop") %>%
arrange(date_of_onset) %>%
mutate(time = row_number()) %>%
select(time, cases) %>%
as.data.frame()
# 2) Run model
out <- estimate_Rt_draws(
incidence = ebola_daily_incidence,
N = 100000,
gamma = 0.2,
beta_breaks = c(1, 230)
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
library(ggplot2)
plot_block_R <- function(df_block, y_label = "R") {
ggplot(df_block) +
geom_rect(aes(xmin = t_start, xmax = t_end, ymin = Lower, ymax = Upper),
fill = "grey80", alpha = 0.7, color = NA) +
geom_segment(aes(x = t_start, xend = t_end, y = Mean, yend = Mean),
size = 1.2, color = "black") +
geom_hline(yintercept = 1, linetype = 2, color = "red") +
labs(x = "Time", y = y_label, title = paste("Estimated", y_label, "by Block")) +
theme_minimal(base_size = 12)
}
# Using your beta blocks:
plot_block_R(df_block_R)
head(out$Rt_series)
out$Rt_plot # print Rt(t) plot over time
load_all()
# Load necessary libraries
library(dplyr)
library(outbreaks)
# Data
data(ebola_sierraleone_2014)
# 1) Build daily incidence data frame (time, cases)
ebola_daily_incidence <- ebola_sierraleone_2014 %>%
filter(!is.na(date_of_onset)) %>%
group_by(date_of_onset) %>%
summarise(cases = n(), .groups = "drop") %>%
arrange(date_of_onset) %>%
mutate(time = row_number()) %>%
select(time, cases) %>%
as.data.frame()
# 2) Run model
out <- estimate_Rt_draws(
incidence = ebola_daily_incidence,
N = 100000,
gamma = 0.2,
beta_breaks = c(1, 230)
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
library(ggplot2)
plot_block_R <- function(df_block, y_label = "R") {
ggplot(df_block) +
geom_rect(aes(xmin = t_start, xmax = t_end, ymin = Lower, ymax = Upper),
fill = "grey80", alpha = 0.7, color = NA) +
geom_segment(aes(x = t_start, xend = t_end, y = Mean, yend = Mean),
size = 1.2, color = "black") +
geom_hline(yintercept = 1, linetype = 2, color = "red") +
labs(x = "Time", y = y_label, title = paste("Estimated", y_label, "by Block")) +
theme_minimal(base_size = 12)
}
# Using your beta blocks:
plot_block_R(df_block_R)
head(out$Rt_series)
out$Rt_plot # print Rt(t) plot over time
library(EpiEstim)
library(dplyr)
library(ggplot2)
# ---- Your SI (parametric) ----
mean_si <- 5     # days
std_si  <- 5    # days
# ---- Prepare incidence ----
# Expecting ebola_daily_incidence to have columns: date (optional), cases (integer)
ebola_sierraleone_2014_epiestim <- ebola_daily_incidence %>%
rename(I = cases)  # EpiEstim looks for column "I"
# ---- Define NON-OVERLAPPING windows ----
# Example: 2..49 (pre), 50..N (post)
t_start <- c(2, 229)
t_end   <- c(230, nrow(ebola_daily_incidence))
stopifnot(length(t_start) == length(t_end))
stopifnot(all(t_start >= 2))
stopifnot(all(t_end <= nrow(ebola_daily_incidence)))
stopifnot(all(t_end >= t_start))
# ---- Estimate R over the two windows ----
res_parametric_si <- estimate_R(
incid  = ebola_sierraleone_2014_epiestim,  # data.frame with "I" (and optionally "dates")
method = "parametric_si",
config = make_config(list(
mean_si = mean_si,
std_si  = std_si,
t_start = t_start,
t_end   = t_end
))
)
# ---- Inspect and plot ----
head(res_parametric_si$R)
# Full 3-panel plot
plot(res_parametric_si, legend = FALSE)
# Rt panel only + horizontal line at 1
plot(res_parametric_si, "R") +
geom_hline(aes(yintercept = 1), lty = 2, col = "red")
# ---- (Optional) Summarise mean R per window ----
summary_by_window <- res_parametric_si$R %>%
mutate(window = paste0("days ", t_start, "–", t_end)) %>%
select(window, `Mean(R)`, `Quantile.0.025(R)`, `Quantile.0.975(R)`)
print(summary_by_window)
library(EpiEstim)
library(dplyr)
library(ggplot2)
# ---- Your SI (parametric) ----
mean_si <- 5     # days
std_si  <- 5    # days
# ---- Prepare incidence ----
# Expecting ebola_daily_incidence to have columns: date (optional), cases (integer)
ebola_sierraleone_2014_epiestim <- ebola_daily_incidence %>%
rename(I = cases)  # EpiEstim looks for column "I"
# ---- Define NON-OVERLAPPING windows ----
# Example: 2..49 (pre), 50..N (post)
t_start <- c(2, 230)
t_end   <- c(229, nrow(ebola_daily_incidence))
stopifnot(length(t_start) == length(t_end))
stopifnot(all(t_start >= 2))
stopifnot(all(t_end <= nrow(ebola_daily_incidence)))
stopifnot(all(t_end >= t_start))
# ---- Estimate R over the two windows ----
res_parametric_si <- estimate_R(
incid  = ebola_sierraleone_2014_epiestim,  # data.frame with "I" (and optionally "dates")
method = "parametric_si",
config = make_config(list(
mean_si = mean_si,
std_si  = std_si,
t_start = t_start,
t_end   = t_end
))
)
# ---- Inspect and plot ----
head(res_parametric_si$R)
# Full 3-panel plot
plot(res_parametric_si, legend = FALSE)
# Rt panel only + horizontal line at 1
plot(res_parametric_si, "R") +
geom_hline(aes(yintercept = 1), lty = 2, col = "red")
# ---- (Optional) Summarise mean R per window ----
summary_by_window <- res_parametric_si$R %>%
mutate(window = paste0("days ", t_start, "–", t_end)) %>%
select(window, `Mean(R)`, `Quantile.0.025(R)`, `Quantile.0.975(R)`)
print(summary_by_window)
beta_mat <- extracted$beta_blocks_samp   # K x n_draws matrix
beta_blocks <- extracted[, grepl("beta_block", names(extracted)), drop = FALSE]
extracted <- out$samples   # or however your object stores them
beta_blocks <- extracted[, grepl("beta_block", names(extracted)), drop = FALSE]
I0_samp     <- extracted$I0
beta_blocks <- extracted$beta_blocks_samp
beta_mat <- extracted$beta_blocks_samp   # K x n_draws matrix
gamma <- out$fixed$gamma                 # if stored there
dim(beta_mat)
summary(beta_mat)
# What’s inside?
names(out)
# What class and shape is samples?
class(out$samples)
dim(out$samples)
head(out$samples)
# Extract β-block draws matrix (rows = draws, cols = blocks)
beta_mat <- as.matrix(out$samples[, grepl("^beta_block_", names(out$samples)), drop = FALSE])
# Gamma from your output
gamma <- out$fixed$gamma
# Non-positives? If >0, you'd be on log-scale; here it should be 0
mean(beta_mat <= 0, na.rm = TRUE)
# Implied R0 if β is natural
R0_nat <- as.numeric(beta_mat) / gamma
quantile(R0_nat, c(0.01, 0.25, 0.5, 0.75, 0.99), na.rm = TRUE)
# Implied R0 if β were log (should look absurd here)
R0_log <- as.numeric(exp(beta_mat)) / gamma
quantile(R0_log, c(0.01, 0.25, 0.5, 0.75, 0.99), na.rm = TRUE)
I0_prop <- out$samples$I0
N       <- out$fixed$N
summary(I0_prop)
summary(I0_prop * N)  # convert to persons
beta_series <- out$estimates$beta_series
# Columns: time, beta_median, beta_lower, beta_upper
Rt_renewal <- transform(
beta_series,
Rt_median = beta_median / gamma,
Rt_lower  = beta_lower  / gamma,
Rt_upper  = beta_upper  / gamma
)
head(Rt_renewal)
# Add a renewal Rt series to your out object
out$Rt_renewal_series <- transform(
out$estimates$beta_series,
Rt_median = beta_median / out$fixed$gamma,
Rt_lower  = beta_lower  / out$fixed$gamma,
Rt_upper  = beta_upper  / out$fixed$gamma
)
library(ggplot2)
df_mech <- transform(
out$Rt_series,
Rt_lower = out$Rt_lower,
Rt_upper = out$Rt_upper
)
p <- ggplot() +
# Renewal (β/γ): blue
geom_ribbon(
data = out$Rt_renewal_series,
aes(x = time, ymin = Rt_lower, ymax = Rt_upper),
fill = "steelblue", alpha = 0.20
) +
geom_line(
data = out$Rt_renewal_series,
aes(x = time, y = Rt_median),
colour = "steelblue", linewidth = 0.8
) +
# Mechanistic (β/γ × S/N): red
geom_ribbon(
data = df_mech,
aes(x = time, ymin = Rt_lower, ymax = Rt_upper),
fill = "firebrick", alpha = 0.15
) +
geom_line(
data = df_mech,
aes(x = time, y = median),
colour = "firebrick", linewidth = 0.8
) +
geom_hline(yintercept = 1, linetype = 2, colour = "grey50") +
labs(
title = "Rt: Renewal (β/γ) vs Mechanistic (β/γ × S/N)",
subtitle = "Blue = renewal (EpiEstim-like); Red = mechanistic with susceptible depletion",
x = "Time", y = expression(R[t])
) +
theme_minimal()
p
# If your St_series is a data.frame with columns time, S_median, S_lower, S_upper:
str(out$St_series)
St_df <- out$St_series
# Median susceptible fraction over time
S_over_N <- St_df$S_median / out$fixed$N
summary(S_over_N)
# Compare to cumulative observed attack rate (lower bound on infections/N)
attack_obs <- cumsum(out$inputs$cases) / out$fixed$N
summary(attack_obs)
tot_cases <- sum(out$inputs$cases)
c( total_cases = tot_cases,
tot_over_N = tot_cases / out$fixed$N )
# Inspect what's inside inputs
names(out$inputs)
str(out$inputs, max.level = 1)
# Common places teams store it
if (!is.null(out$inputs$incidence)) {
head(out$inputs$incidence)
}
# If not there, check other likely fields
cand_names <- c("incidence", "incid", "data", "original_incidence", "observed")
for (nm in cand_names) {
if (!is.null(out$inputs[[nm]])) {
cat("\nFound:", nm, "\n"); print(head(out$inputs[[nm]])); break
}
}
# If the object is still in your workspace
stopifnot(exists("ebola_daily_incidence"))
obs_cases <- ebola_daily_incidence$cases
N <- out$fixed$N
tot_cases  <- sum(obs_cases, na.rm = TRUE)
att_series <- cumsum(obs_cases) / N  # observed cumulative attack (lower bound)
c(total_cases = tot_cases, attack_rate_final = tail(att_series, 1))
summary(att_series)
# Visual contrast with your modeled S/N (median)
S_over_N <- out$St_series$S_median / N
par(mfrow = c(1, 2))
plot(S_over_N, type = "l", ylim = c(0,1),
main = "Modeled S/N (median)", xlab = "Time", ylab = "Fraction")
plot(att_series, type = "l", ylim = c(0,1),
main = "Observed cumulative attack", xlab = "Time", ylab = "Cumulative cases / N")
par(mfrow = c(1, 1))
out_bigN <- estimate_Rt(
incidence   = ebola_daily_incidence,
N           = 1e6,              # try 1e6, 2e6, … up to the plausible catchment
gamma       = out$fixed$gamma,
beta_breaks = c(1, 230)         # same two windows you used
)
# Compare S/N and Rt overlay as before
S_over_N_big <- out_bigN$St_series$S_median / out_bigN$fixed$N
summary(S_over_N_big)
# Renewal Rt (β/γ) stays the same scale; mechanistic Rt (β/γ × S/N) should move up (less depletion).
# Using modeled (median) infections from −ΔS (approx):
lambda_med <- pmax(c(-diff(out$St_series$S_median), NA), 0)  # last element NA
rho_hat    <- sum(ebola_daily_incidence$cases, na.rm = TRUE) / sum(lambda_med, na.rm = TRUE)
rho_hat
rho_cum <- att_obs_final / att_model_final
out <- estimate_Rt(
incidence   = ebola_daily_incidence,
N           = 1e6,              # try 1e6, 2e6, … up to the plausible catchment
gamma       = out$fixed$gamma,
beta_breaks = c(1, 230)         # same two windows you used
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
# 2) Run model
out <- estimate_Rt_draws(
incidence = ebola_daily_incidence,
N = 1000000,
gamma = 0.2,
beta_breaks = c(1, 230)
)
df_block_R <- block_Rt_from_draws(
R_draws = out$posterior_paths$R,
starts  = out$blocks$beta_starts,  # or your custom windows (see below)
ends    = out$blocks$beta_ends
)
df_block_R
library(ggplot2)
plot_block_R <- function(df_block, y_label = "R") {
ggplot(df_block) +
geom_rect(aes(xmin = t_start, xmax = t_end, ymin = Lower, ymax = Upper),
fill = "grey80", alpha = 0.7, color = NA) +
geom_segment(aes(x = t_start, xend = t_end, y = Mean, yend = Mean),
size = 1.2, color = "black") +
geom_hline(yintercept = 1, linetype = 2, color = "red") +
labs(x = "Time", y = y_label, title = paste("Estimated", y_label, "by Block")) +
theme_minimal(base_size = 12)
}
# Using your beta blocks:
plot_block_R(df_block_R)
head(out$Rt_series)
out$Rt_plot # print Rt(t) plot over time
t_star <- 240  # pick a time in the middle of the decline
R_draws  <- out_bigN$posterior_paths$R[t_star, ]       # T x D
S_draws  <- out_bigN$posterior_paths$S[t_star, ]       # T x D
beta_draws <- out_bigN$posterior_paths$beta[t_star, ]  # T x D
N_big    <- out_bigN$fixed$N
gamma    <- out_bigN$fixed$gamma
# Should be (nearly) identical:
cor(R_draws, (beta_draws/gamma) * (S_draws/N_big), use = "complete.obs")
q3 <- function(x) stats::quantile(x, c(0.025, 0.5, 0.975), names = FALSE, type = 8)
# Quantiles recomputed right here:
q_R_fresh <- q3(R_draws)
# Quantiles used in the plot (from your object):
Rt_m   <- with(out_bigN$Rt_series, median[time == t_star])
Rt_lo  <- out_bigN$Rt_lower[which(out_bigN$Rt_series$time == t_star)]
Rt_hi  <- out_bigN$Rt_upper[which(out_bigN$Rt_series$time == t_star)]
cbind(fresh = q_R_fresh, plotted = c(Rt_lo, Rt_m, Rt_hi))
# What’s actually there?
is.null(out_bigN$posterior_paths)
names(out_bigN$posterior_paths)
# Structures and dimensions
str(out_bigN$posterior_paths, max.level = 1)
lapply(out_bigN$posterior_paths, function(x) list(class = class(x), dim = dim(x), length = length(x)))
